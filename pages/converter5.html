<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image to WebP Converter</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        :root {
            --primary: #4a6bff;
            --secondary: #f5f7ff;
            --text: #333;
            --light-text: #666;
            --border: #ddd;
            --shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        /* ... (CSS from previous version, snipped for brevity) ... */
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        body { background-color: #f9f9f9; color: var(--text); line-height: 1.6; }
        .container { max-width: 1200px; margin: 0 auto; padding: 2rem; }
        header { text-align: center; margin-bottom: 2rem; }
        h1 { font-size: 2.5rem; margin-bottom: 0.5rem; color: var(--primary); }
        .subtitle { color: var(--light-text); font-size: 1.1rem; }
        .upload-area { background-color: white; border-radius: 12px; padding: 2rem; box-shadow: var(--shadow); margin-bottom: 2rem; text-align: center; border: 2px dashed var(--border); transition: all 0.3s ease; position: relative; }
        .upload-area.active { border-color: var(--primary); background-color: var(--secondary); }
        #drag-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(74, 107, 255, 0.1); z-index: 9999; display: none; pointer-events: none; }
        .upload-area h2 { margin-bottom: 1rem; font-size: 1.5rem; }
        .upload-area p { color: var(--light-text); margin-bottom: 1.5rem; }
        .upload-options { display: flex; justify-content: center; gap: 1rem; flex-wrap: wrap; margin-bottom: 1.5rem; }
        .btn { padding: 0.8rem 1.5rem; border: none; border-radius: 8px; font-weight: 600; cursor: pointer; transition: all 0.2s ease; display: inline-flex; align-items: center; gap: 0.5rem; }
        .btn-primary { background-color: var(--primary); color: white; }
        .btn-primary:hover { background-color: #3a5bef; transform: translateY(-2px); }
        .btn-secondary { background-color: var(--secondary); color: var(--primary); border: 1px solid var(--border); }
        .btn-secondary:hover { background-color: #e0e5ff; }
        .btn-success { background-color: #28a745; color: white; }
        .btn-success:hover { background-color: #218838; }
        .url-input { display: flex; gap: 0.5rem; width: 100%; max-width: 600px; margin: 0 auto; }
        .url-input input { flex: 1; padding: 0.8rem 1rem; border: 1px solid var(--border); border-radius: 8px; font-size: 1rem; }
        .url-input button { white-space: nowrap; }
        #fileInput { display: none; }
        .results { display: none; background-color: white; border-radius: 12px; padding: 2rem; box-shadow: var(--shadow); }
        .results-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem; flex-wrap: wrap; gap: 1rem; }
        .results-title { font-size: 1.5rem; }
        .bulk-actions { display: flex; flex-wrap: wrap; gap: 0.5rem; }
        .image-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); gap: 1.5rem; }
        .image-card { border: 1px solid var(--border); border-radius: 8px; overflow: hidden; transition: all 0.3s ease; display: flex; flex-direction: column; }
        .image-card:hover { transform: translateY(-5px); box-shadow: var(--shadow); }
        .image-preview { width: 100%; height: 200px; object-fit: cover; background-color: #f0f0f0; }
        .image-info { padding: 1rem; display: flex; flex-direction: column; flex-grow: 1; }
        .image-name { font-weight: 600; margin-bottom: 0.5rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .image-size { color: var(--light-text); font-size: 0.9rem; margin-bottom: 1rem; }
        .image-actions { display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem; margin-top: auto; }
        .image-actions .copy-url-btn { grid-column: 1 / -1; }
        .image-actions .btn { padding: 0.5rem; font-size: 0.9rem; flex: 1; justify-content: center; }
        .loading { display: none; text-align: center; padding: 2rem; }
        .spinner { width: 40px; height: 40px; border: 4px solid rgba(0, 0, 0, 0.1); border-radius: 50%; border-top-color: var(--primary); animation: spin 1s ease-in-out infinite; margin: 0 auto 1rem; }
        @keyframes spin { to { transform: rotate(360deg); } }
        .toast { position: fixed; bottom: 20px; right: 20px; background-color: #333; color: white; padding: 1rem 1.5rem; border-radius: 8px; box-shadow: var(--shadow); transform: translateY(150%); opacity: 0; transition: all 0.4s cubic-bezier(0.21, 1.05, 0.58, 1); z-index: 10000; max-width: 320px; }
        .toast.show { transform: translateY(0); opacity: 1; }
        
        /* New Styles for Guided Paste Modal */
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.6); z-index: 9990; display: none; align-items: center; justify-content: center; }
        .modal-content { background: white; padding: 2rem; border-radius: 12px; box-shadow: 0 5px 20px rgba(0,0,0,0.2); text-align: center; max-width: 450px; width: 90%; }
        .modal-content h3 { margin-bottom: 1rem; color: var(--primary); }
        .modal-content p { margin-bottom: 1.5rem; color: var(--light-text); line-height: 1.5; }
        .modal-content kbd { background-color: #eee; border-radius: 3px; border: 1px solid #b4b4b4; color: #333; display: inline-block; font-size: .85em; font-weight: 700; line-height: 1; padding: 2px 4px; white-space: nowrap; }
        .modal-progress { font-size: 1.2rem; font-weight: bold; margin-bottom: 1.5rem; display: block; }
        .modal-actions .btn { width: 100%; justify-content: center; }
        .modal-actions .btn:not(:last-child) { margin-bottom: 0.5rem; }

        @media (max-width: 768px) { .container { padding: 1rem; } .upload-options { flex-direction: column; } .url-input { flex-direction: column; } .image-grid { grid-template-columns: 1fr; } .results-header { flex-direction: column; align-items: flex-start; } .toast { left: 20px; right: 20px; width: auto; } }
    </style>
</head>
<body>
    <div id="drag-overlay"></div>
    <div class="container">
        <header>
            <h1>Image to WebP Converter</h1>
            <p class="subtitle">Convert local files, clipboard images, or even extract all images from a web page</p>
        </header>

        <div class="upload-area" id="dropArea">
            <!-- ... unchanged ... -->
            <h2>Upload Your Images</h2>
            <p>Drag & drop anywhere, paste from clipboard, select files, or fetch from a URL</p>
            <div class="upload-options">
                <button class="btn btn-primary" id="selectFilesBtn"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5z"/><path d="M7.646 1.146a.5.5 0 0 1 .708 0l3 3a.5.5 0 0 1-.708.708L8.5 2.707V11.5a.5.5 0 0 1-1 0V2.707L5.354 4.854a.5.5 0 1 1-.708-.708l3-3z"/></svg> Select Files</button>
                <button class="btn btn-secondary" id="pasteBtn"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M8 1a2.5 2.5 0 0 1 2.5 2.5V4h-5v-.5A2.5 2.5 0 0 1 8 1zm3.5 3v-.5a3.5 3.5 0 1 0-7 0V4H1v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V4h-3.5zM2 5h12v9a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V5z"/></svg> Paste Image</button>
            </div>
            <div class="url-input">
                <input type="text" id="imageUrl" placeholder="Enter image or page URL..."><button class="btn btn-primary" id="addUrlBtn">Fetch from URL</button>
            </div>
            <input type="file" id="fileInput" accept="image/*" multiple>
        </div>

        <div class="loading" id="loadingIndicator">
            <div class="spinner"></div>
            <p id="loadingText">Converting images...</p>
        </div>

        <div class="results" id="resultsSection">
            <div class="results-header">
                <h3 class="results-title">Converted Images</h3>
                <div class="bulk-actions">
                    <!-- NEW BUTTON for Guided Paste -->
                    <button class="btn btn-success" id="guidedPasteBtn">Upload to ImgBB (Guided)</button>
                    <button class="btn btn-secondary" id="copyAllHtmlBtn">Copy as HTML</button>
                    <button class="btn btn-primary" id="downloadAllBtn">Download All (.zip)</button>
                </div>
            </div>
            <div class="image-grid" id="imageGrid"></div>
        </div>
    </div>
    
    <!-- Toast Notification (unchanged) -->
    <div class="toast" id="toast"></div>

    <!-- NEW Guided Paste Modal -->
    <div class="modal-overlay" id="guidedPasteModal">
        <div class="modal-content">
            <h3>Guided Paste to ImgBB</h3>
            <p>
                The next image is copied. Go to the ImgBB tab, click their upload area, and press <kbd>Ctrl</kbd> + <kbd>V</kbd> (or <kbd>Cmd</kbd> + <kbd>V</kbd>) to paste it.
            </p>
            <span class="modal-progress" id="modalProgress">Image 1 of 5</span>
            <div class="modal-actions">
                <button class="btn btn-primary" id="copyNextImgBtn">Copy Next Image</button>
                <button class="btn btn-secondary" id="closeModalBtn">Done / Close</button>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // --- DOM Elements ---
            const guidedPasteBtn = document.getElementById('guidedPasteBtn');
            const guidedPasteModal = document.getElementById('guidedPasteModal');
            const modalProgress = document.getElementById('modalProgress');
            const copyNextImgBtn = document.getElementById('copyNextImgBtn');
            const closeModalBtn = document.getElementById('closeModalBtn');
            // (Other DOM elements are unchanged)
            const dropArea = document.getElementById('dropArea'), dragOverlay = document.getElementById('drag-overlay'), fileInput = document.getElementById('fileInput'), selectFilesBtn = document.getElementById('selectFilesBtn'), pasteBtn = document.getElementById('pasteBtn'), imageUrlInput = document.getElementById('imageUrl'), addUrlBtn = document.getElementById('addUrlBtn'), loadingIndicator = document.getElementById('loadingIndicator'), loadingText = document.getElementById('loadingText'), resultsSection = document.getElementById('resultsSection'), imageGrid = document.getElementById('imageGrid'), downloadAllBtn = document.getElementById('downloadAllBtn'), copyAllHtmlBtn = document.getElementById('copyAllHtmlBtn'), toast = document.getElementById('toast');
            
            let convertedImages = [];
            let pasteGuideIndex = 0;

            // --- Event Listeners ---
            guidedPasteBtn.addEventListener('click', startGuidedPaste);
            copyNextImgBtn.addEventListener('click', advanceGuidedPaste);
            closeModalBtn.addEventListener('click', () => guidedPasteModal.style.display = 'none');
            // (Other event listeners are unchanged)
            selectFilesBtn.addEventListener('click', () => fileInput.click()); fileInput.addEventListener('change', (e) => handleFiles(e.target.files)); pasteBtn.addEventListener('click', handlePaste); addUrlBtn.addEventListener('click', handleUrlInput); imageUrlInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') handleUrlInput(); }); downloadAllBtn.addEventListener('click', downloadAllImagesAsZip); copyAllHtmlBtn.addEventListener('click', copyAllAsHtml); imageGrid.addEventListener('click', handleCardActions); ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => document.addEventListener(eventName, preventDefaults, false)); function preventDefaults(e) { e.preventDefault(); e.stopPropagation(); } document.addEventListener('dragenter', () => { dropArea.classList.add('active'); dragOverlay.style.display = 'block'; }); document.addEventListener('dragleave', (e) => { if (e.relatedTarget === null) unhighlight(); }); document.addEventListener('drop', (e) => { unhighlight(); handleFiles(e.dataTransfer.files); }); function unhighlight() { dropArea.classList.remove('active'); dragOverlay.style.display = 'none'; }


            // --- NEW Guided Paste Functions ---
            function startGuidedPaste() {
                if (convertedImages.length === 0) {
                    showToast('No images to upload!');
                    return;
                }
                // Check for secure context, which is required for clipboard image writing
                if (!navigator.clipboard || !navigator.clipboard.write) {
                    showToast('Guided paste requires a secure (HTTPS) connection and a modern browser.', 5000);
                    return;
                }
                pasteGuideIndex = 0;
                guidedPasteModal.style.display = 'flex';
                updateModalState();
                copyImageForPasting(pasteGuideIndex);
            }
            
            function advanceGuidedPaste() {
                pasteGuideIndex++;
                updateModalState();
                copyImageForPasting(pasteGuideIndex);
            }

            function updateModalState() {
                const total = convertedImages.length;
                modalProgress.textContent = `Image ${pasteGuideIndex + 1} of ${total}`;
                if (pasteGuideIndex >= total - 1) {
                    copyNextImgBtn.disabled = true;
                    copyNextImgBtn.textContent = 'All Images Copied!';
                } else {
                    copyNextImgBtn.disabled = false;
                    copyNextImgBtn.textContent = 'Copy Next Image';
                }
            }

            // This function is crucial. It copies the actual image data, not a Data URL.
            // This is what ImgBB's paste handler expects.
            async function copyImageForPasting(index) {
                if (index >= convertedImages.length) return;

                try {
                    const image = convertedImages[index];
                    const blob = await (await fetch(image.url)).blob();
                    
                    // The ClipboardItem API is required for writing blobs/files.
                    await navigator.clipboard.write([
                        new ClipboardItem({ [blob.type]: blob })
                    ]);

                    showToast(`Image ${index + 1} copied to clipboard.`);
                } catch (error) {
                    console.error('Failed to copy image for pasting:', error);
                    showToast('Copy failed. This feature works best on HTTPS sites.', 5000);
                    guidedPasteModal.style.display = 'none'; // Hide modal on failure
                }
            }

            // --- Core Logic & UI (mostly unchanged) ---
            function handleCardActions(e) { /* ... unchanged ... */ const button = e.target.closest('button'); if (!button) return; const index = button.dataset.index; if (button.classList.contains('download-btn')) downloadImage(index); if (button.classList.contains('copy-image-btn')) copyImageAsDataUrl(index); if (button.classList.contains('copy-url-btn')) copySingleUrl(index); }
            async function handleFiles(files) { /* ... unchanged ... */ if (files.length === 0) return; showLoading(true, 'Converting images...'); const imageFiles = Array.from(files).filter(file => file.type && file.type.startsWith('image/')); if (imageFiles.length === 0) { showToast('No valid image files were provided.'); showLoading(false); return; } const conversionPromises = imageFiles.map(file => convertToWebP(file).then(webpBlob => ({ original: file, webp: new File([webpBlob], `${file.name.split('.').slice(0, -1).join('.')}.webp`, { type: 'image/webp' }), url: URL.createObjectURL(webpBlob) })).catch(error => { console.error(`Error converting ${file.name}:`, error); showToast(`Could not convert ${file.name}.`); return null; })); const newImages = (await Promise.all(conversionPromises)).filter(Boolean); if (newImages.length > 0) { convertedImages.push(...newImages); updateResults(); resultsSection.style.display = 'block'; showToast(`Successfully converted ${newImages.length} image(s).`); } showLoading(false); }
            function updateResults() { /* ... unchanged ... */ imageGrid.innerHTML = ''; convertedImages.forEach((image, index) => { const card = document.createElement('div'); card.className = 'image-card'; card.innerHTML = ` <img src="${image.url}" alt="${image.webp.name}" class="image-preview" loading="lazy"> <div class="image-info"> <div class="image-name" title="${image.webp.name}">${image.webp.name}</div> <div class="image-size"> ${formatFileSize(image.original.size)} &rarr; <b>${formatFileSize(image.webp.size)}</b> </div> <div class="image-actions"> <button class="btn btn-primary download-btn" data-index="${index}">Download</button> <button class="btn btn-secondary copy-image-btn" data-index="${index}">Copy (Data URL)</button> </div> </div>`; imageGrid.appendChild(card); }); }
            async function copyImageAsDataUrl(index) { /* ... unchanged ... */ try { const image = convertedImages[index]; const blob = await (await fetch(image.url)).blob(); const dataUrl = await new Promise(r => { const reader = new FileReader(); reader.onload = () => r(reader.result); reader.readAsDataURL(blob); }); await navigator.clipboard.writeText(dataUrl); showToast('Image (as Data URL) copied to clipboard.'); } catch (error) { console.error('Failed to copy image:', error); showToast('Copy failed. Your browser may block this action in incognito or on local files.', 5000); } }
            
            // Other functions (handlePaste, handleUrlInput, etc.) are unchanged and snipped for clarity
            async function handlePaste() { try { const clipboardItems = await navigator.clipboard.read(); for (const item of clipboardItems) { const imageType = item.types.find(type => type.startsWith('image/')); if (imageType) { const blob = await item.getType(imageType); const file = new File([blob], 'pasted-image.' + imageType.split('/')[1], { type: imageType }); handleFiles([file]); showToast('Pasted image added for conversion.'); return; } } showToast('No image found in clipboard.'); } catch (err) { console.error('Clipboard API error:', err); showToast('Failed to access clipboard. This feature requires browser permission.'); } }
            async function handleUrlInput() { const url = imageUrlInput.value.trim(); if (!url) { showToast('Please enter a valid URL.'); return; } showLoading(true, "Fetching from URL..."); const isDirectImageUrl = /\.(jpg|jpeg|png|gif|bmp|svg|webp)$/i.test(url); try { if (isDirectImageUrl) { const response = await fetchWithProxy(url); const blob = await response.blob(); const contentType = response.headers.get('content-type'); if (!contentType || !contentType.startsWith('image/')) { throw new Error('URL does not point to a valid image.'); } const filename = url.split('/').pop().split('?')[0] || 'image_from_url'; await handleFiles([new File([blob], filename, { type: contentType })]); } else { await extractImagesFromPage(url); } imageUrlInput.value = ''; } catch (error) { console.error('URL processing error:', error); showToast(`Error: ${error.message}`); } finally { showLoading(false); } }
            async function extractImagesFromPage(pageUrl) { showLoading(true, "Scanning page for images..."); try { const response = await fetchWithProxy(pageUrl); const htmlText = await response.text(); const parser = new DOMParser(); const doc = parser.parseFromString(htmlText, 'text/html'); const imageElements = doc.querySelectorAll('img'); if (imageElements.length === 0) { showToast('No <img> tags found on the provided page.'); return; } showToast(`Found ${imageElements.length} images. Fetching...`); const fetchPromises = Array.from(imageElements) .map(img => img.src) .filter(Boolean) .map(src => { const absoluteUrl = new URL(src, pageUrl).href; return fetchWithProxy(absoluteUrl) .then(res => res.blob()) .then(blob => { if (blob.type.startsWith('image/')) { const filename = absoluteUrl.split('/').pop().split(/[?#]/)[0] || 'scraped-image'; return new File([blob], filename, { type: blob.type }); } return null; }) .catch(() => null); }); const files = (await Promise.all(fetchPromises)).filter(Boolean); if (files.length > 0) { await handleFiles(files); } else { showToast("Could not fetch any valid images from the page."); } } catch(error) { showToast('Failed to fetch or parse the page.'); console.error(error); } }
            function fetchWithProxy(url) { const proxyUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`; return fetch(proxyUrl); }
            function convertToWebP(file) { return new Promise((resolve, reject) => { const reader = new FileReader(); reader.readAsDataURL(file); reader.onload = e => { const img = new Image(); img.src = e.target.result; img.onload = () => { const canvas = document.createElement('canvas'); canvas.width = img.width; canvas.height = img.height; const ctx = canvas.getContext('2d'); ctx.drawImage(img, 0, 0); canvas.toBlob(blob => { if (blob) resolve(blob); else reject(new Error('Canvas to Blob conversion failed.')); }, 'image/webp', 0.8); }; img.onerror = reject; }; reader.onerror = reject; }); }
            function downloadImage(index) { const image = convertedImages[index]; const a = document.createElement('a'); a.href = image.url; a.download = image.webp.name; document.body.appendChild(a); a.click(); document.body.removeChild(a); showToast(`Downloading ${image.webp.name}`); }
            async function downloadAllImagesAsZip() { if (convertedImages.length === 0) { showToast('No images to download.'); return; } showLoading(true, "Creating ZIP file..."); try { const zip = new JSZip(); const blobs = await Promise.all(convertedImages.map(img => fetch(img.url).then(res => res.blob()))); blobs.forEach((blob, i) => zip.file(convertedImages[i].webp.name, blob)); const content = await zip.generateAsync({ type: 'blob' }); const a = document.createElement('a'); a.href = URL.createObjectURL(content); a.download = 'converted-images.zip'; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(a.href); showToast('ZIP file download started.'); } catch(error) { console.error("Error creating ZIP:", error); showToast("Failed to create ZIP file."); } finally { showLoading(false); } }
            async function copyAllAsHtml() { if (convertedImages.length === 0) { showToast('No images to copy.'); return; } showLoading(true, 'Generating HTML...'); try { const dataUrlPromises = convertedImages.map(async (image) => { const blob = await (await fetch(image.url)).blob(); const dataUrl = await new Promise(r => { const reader = new FileReader(); reader.onload = () => r(reader.result); reader.readAsDataURL(blob); }); return `<img src="${dataUrl}" alt="${image.webp.name}" />`; }); const htmlSnippets = await Promise.all(dataUrlPromises); const finalHtml = htmlSnippets.join('\n'); await navigator.clipboard.writeText(finalHtml); showToast(`Copied ${convertedImages.length} images as HTML.`); } catch (error) { console.error('Failed to copy as HTML:', error); showToast('Copy failed. Your browser may block this action in incognito or on local files.', 5000); } finally { showLoading(false); } }
            function formatFileSize(bytes) { if (bytes === 0) return '0 Bytes'; const k = 1024; const sizes = ['Bytes', 'KB', 'MB', 'GB']; const i = Math.floor(Math.log(bytes) / Math.log(k)); return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i]; }
            function showLoading(show, text = 'Converting images...') { loadingText.textContent = text; loadingIndicator.style.display = show ? 'block' : 'none'; }
            let toastTimer; function showToast(message, duration = 3000) { clearTimeout(toastTimer); toast.textContent = message; toast.classList.add('show'); toastTimer = setTimeout(() => { toast.classList.remove('show'); }, duration); }
        });
    </script>
</body>
</html>
